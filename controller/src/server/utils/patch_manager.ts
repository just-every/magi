/**
 * Patch Manager Module
 *
 * Handles patch risk assessment, auto-merge decisions, and conflict resolution
 * for code changes generated by MAGI agents.
 */

import { execSync, ExecSyncOptions } from 'child_process';
import crypto from 'crypto';
import fs from 'fs';
import path from 'path';
import { getDB } from './db.js';
// import { computeMetrics } from '../managers/commit_metrics.js';
import { Metrics } from '../../types/index.js';
import { getDefaultBranch } from './git_utils.js';
import { getProject } from './db_utils.js';

/**
 * Update patch status in the database
 */
export async function updatePatchStatus(
    patchId: number,
    status: 'pending' | 'applied' | 'failed' | 'conflicted',
    error?: string
): Promise<void> {
    const client = await getDB();
    try {
        await client.query(
            `UPDATE patches
             SET status = $2,
                 error_message = $3,
                 updated_at = NOW()
             WHERE id = $1`,
            [patchId, status, error || null]
        );
    } catch (err) {
        console.error(`Failed to update patch ${patchId} status:`, err);
        throw err;
    } finally {
        client.release();
    }
}

/**
 * Execute git command with proper error handling
 */
function executeGitCommand(
    command: string,
    cwd: string,
    options?: ExecSyncOptions
): { success: boolean; output?: string; error?: string } {
    try {
        const output = execSync(command, {
            cwd,
            stdio: 'pipe',
            encoding: 'utf-8',
            ...options,
        });
        return { success: true, output: output.toString().trim() };
    } catch (error: any) {
        const errorMessage = error.stderr
            ? error.stderr.toString()
            : error.message;
        return { success: false, error: errorMessage };
    }
}

export type MergePolicy = 'none' | 'low_risk' | 'moderate_risk' | 'all';
export type RiskLevel = 'low' | 'moderate' | 'high' | 'critical';

export interface PatchData {
    id: number;
    process_id: string;
    project_id: string;
    branch_name: string;
    commit_message: string;
    patch_content: string;
    metrics?: Metrics;
    status: 'pending' | 'applied' | 'rejected' | 'superseded';
    created_at: Date;
    applied_at?: Date;
    applied_by?: string;
    rejection_reason?: string;
    merge_commit_sha?: string;
}

export interface PatchRiskAssessment {
    riskLevel: RiskLevel;
    riskScore: number;
    canAutoMerge: boolean;
    reasons: string[];
    recommendation: string;
}

/**
 * Get environment-configured merge policies
 */
export function getMergePolicies(): {
    magiProjects: MergePolicy;
    externalProjects: MergePolicy;
} {
    return {
        magiProjects: (process.env.AUTO_MERGE_MAGI_PROJECTS ||
            'all') as MergePolicy,
        externalProjects: (process.env.AUTO_MERGE_EXISTING_PROJECTS ||
            'low_risk') as MergePolicy,
    };
}

/**
 * Get risk thresholds from environment or use defaults
 */
function getRiskThresholds(): { low: number; moderate: number; high: number } {
    return {
        low: parseFloat(process.env.LOW_RISK_MAX || '0.25'),
        moderate: parseFloat(process.env.MOD_RISK_MAX || '0.55'),
        high: parseFloat(process.env.HIGH_RISK_MAX || '0.75'),
    };
}

/**
 * Classify risk score into risk level
 */
export function classifyRiskLevel(riskScore: number): RiskLevel {
    const thresholds = getRiskThresholds();

    if (riskScore <= thresholds.low) return 'low';
    if (riskScore <= thresholds.moderate) return 'moderate';
    if (riskScore <= thresholds.high) return 'high';
    return 'critical';
}

/**
 * Assess the risk of a patch based on its metrics and content
 */
export function assessPatchRisk(patch: PatchData): PatchRiskAssessment {
    const reasons: string[] = [];
    let riskScore = patch.metrics?.score || 0;

    // Additional risk factors specific to patches
    const patchLines = patch.patch_content.split('\n');

    // Check for large patches
    const additions = patchLines.filter(l => l.startsWith('+')).length;
    const deletions = patchLines.filter(l => l.startsWith('-')).length;
    const totalChanges = additions + deletions;

    if (totalChanges > 1000) {
        riskScore += 0.2;
        reasons.push('Very large patch (>1000 lines)');
    } else if (totalChanges > 500) {
        riskScore += 0.1;
        reasons.push('Large patch (>500 lines)');
    }

    // Check for high-risk patterns in patch content
    const dangerousPatterns = [
        { pattern: /DROP\s+TABLE/i, reason: 'Contains DROP TABLE statement' },
        { pattern: /TRUNCATE/i, reason: 'Contains TRUNCATE statement' },
        { pattern: /rm\s+-rf/i, reason: 'Contains rm -rf command' },
        { pattern: /sudo/i, reason: 'Contains sudo command' },
        { pattern: /force\s+push/i, reason: 'Contains force push' },
    ];

    for (const { pattern, reason } of dangerousPatterns) {
        if (pattern.test(patch.patch_content)) {
            riskScore += 0.3;
            reasons.push(reason);
        }
    }

    // Check if patch touches critical files
    const criticalPaths = [
        '.env',
        'docker-compose.yml',
        'package.json',
        'requirements.txt',
        'Gemfile',
        'go.mod',
    ];

    for (const criticalPath of criticalPaths) {
        if (patch.patch_content.includes(`diff --git a/${criticalPath}`)) {
            riskScore += 0.15;
            reasons.push(`Modifies critical file: ${criticalPath}`);
        }
    }

    // Cap risk score at 1.0
    riskScore = Math.min(riskScore, 1.0);

    const riskLevel = classifyRiskLevel(riskScore);

    // Determine if patch can be auto-merged based on policy
    const policies = getMergePolicies();
    // const project = patch.project_id; // We'll need to fetch project details

    let canAutoMerge = false;
    let recommendation = '';

    // This will be updated after we fetch project details
    // For now, we'll use a placeholder
    const isGeneratedProject = false; // TODO: Fetch from database
    const policy = isGeneratedProject
        ? policies.magiProjects
        : policies.externalProjects;

    switch (policy) {
        case 'none':
            canAutoMerge = false;
            recommendation = 'Manual review required (policy: none)';
            break;
        case 'low_risk':
            canAutoMerge = riskLevel === 'low';
            recommendation =
                riskLevel === 'low'
                    ? 'Safe to auto-merge'
                    : 'Manual review required (risk too high)';
            break;
        case 'moderate_risk':
            canAutoMerge = riskLevel === 'low' || riskLevel === 'moderate';
            recommendation = canAutoMerge
                ? 'Can be auto-merged'
                : 'Manual review required (high/critical risk)';
            break;
        case 'all':
            canAutoMerge = riskLevel !== 'critical';
            recommendation = canAutoMerge
                ? 'Will be auto-merged'
                : 'Manual review strongly recommended (critical risk)';
            break;
    }

    if (reasons.length === 0 && riskLevel === 'low') {
        reasons.push('Low complexity changes');
    }

    return {
        riskLevel,
        riskScore,
        canAutoMerge,
        reasons,
        recommendation,
    };
}

/**
 * Apply a patch to a project repository
 */
export async function applyPatch(
    patchId: number,
    projectPath: string,
    autoMerge: boolean = false
): Promise<{ success: boolean; error?: string; mergeCommitSha?: string }> {
    const client = await getDB();

    try {
        // Validate project path exists
        if (!fs.existsSync(projectPath)) {
            throw new Error(`Project directory does not exist: ${projectPath}`);
        }

        // Validate it's a git repository
        const gitDir = path.join(projectPath, '.git');
        if (!fs.existsSync(gitDir)) {
            throw new Error(`Not a git repository: ${projectPath}`);
        }

        // Fetch patch from database
        const patchResult = await client.query(
            'SELECT * FROM patches WHERE id = $1 AND status = $2',
            [patchId, 'pending']
        );

        if (patchResult.rows.length === 0) {
            return {
                success: false,
                error: 'Patch not found or already processed',
            };
        }

        const patch: PatchData = patchResult.rows[0];

        // Create temporary patch file with random name
        const randomId = crypto.randomBytes(16).toString('hex');
        const tmpFile = path.join('/tmp', `patch-${patchId}-${randomId}.patch`);
        fs.writeFileSync(tmpFile, patch.patch_content, { mode: 0o600 });

        try {
            // Get default branch for the repository
            const defaultBranch = getDefaultBranch(projectPath);

            // Check current branch
            const currentBranchResult = executeGitCommand(
                'git rev-parse --abbrev-ref HEAD',
                projectPath
            );
            let currentBranch = currentBranchResult.success
                ? currentBranchResult.output
                : null;

            // If we're in a detached HEAD state or on wrong branch, checkout the default branch
            if (
                !currentBranch ||
                currentBranch === 'HEAD' ||
                (currentBranch !== defaultBranch && autoMerge)
            ) {
                console.log(
                    `[patch-manager] Checking out default branch: ${defaultBranch}`
                );
                const checkoutResult = executeGitCommand(
                    `git checkout ${defaultBranch}`,
                    projectPath
                );
                if (!checkoutResult.success) {
                    // Try to create the branch if it doesn't exist (empty repo case)
                    const createBranchResult = executeGitCommand(
                        `git checkout -b ${defaultBranch}`,
                        projectPath
                    );
                    if (!createBranchResult.success) {
                        throw new Error(
                            `Failed to checkout branch ${defaultBranch}: ${checkoutResult.error}`
                        );
                    }
                }
                currentBranch = defaultBranch;
            }

            // Check if patch can be applied cleanly
            const checkResult = executeGitCommand(
                `git apply --check "${tmpFile}"`,
                projectPath
            );
            if (!checkResult.success) {
                throw new Error(
                    `Patch cannot be applied: ${checkResult.error}`
                );
            }

            // Apply the patch
            let applyResult = executeGitCommand(
                `git apply "${tmpFile}"`,
                projectPath
            );
            if (!applyResult.success) {
                // If normal apply fails, try with --3way for better merge handling
                console.log(
                    '[patch-manager] Normal apply failed, trying 3-way merge'
                );

                // Check if repository has enough history for 3-way merge
                const hasHistory = executeGitCommand(
                    'git rev-list --count HEAD',
                    projectPath
                );
                if (
                    hasHistory.success &&
                    parseInt(hasHistory.output || '0') > 0
                ) {
                    applyResult = executeGitCommand(
                        `git apply --3way "${tmpFile}"`,
                        projectPath
                    );
                    if (!applyResult.success) {
                        throw new Error(
                            `3-way merge failed: ${applyResult.error}`
                        );
                    }
                } else {
                    throw new Error(
                        'Repository lacks sufficient history for 3-way merge'
                    );
                }
            }

            // Stage changes
            const stageResult = executeGitCommand('git add -A', projectPath);
            if (!stageResult.success) {
                throw new Error(
                    `Failed to stage changes: ${stageResult.error}`
                );
            }

            // Commit changes with properly escaped message
            const sanitizedMessage = patch.commit_message
                .replace(/'/g, "'\"'\"'") // Escape single quotes for shell
                .replace(/\n/g, '\\n') // Escape newlines
                .trim()
                .substring(0, 1000);
            const commitMessage = `${sanitizedMessage}\n\nApplied patch #${patchId}`;

            // Use safer approach to avoid command injection
            const commitFile = path.join(
                '/tmp',
                `commit-msg-${patchId}-${crypto.randomBytes(8).toString('hex')}.txt`
            );
            fs.writeFileSync(commitFile, commitMessage, { mode: 0o600 });
            try {
                const commitResult = executeGitCommand(
                    `git commit -F "${commitFile}"`,
                    projectPath
                );
                if (!commitResult.success) {
                    throw new Error(
                        `Failed to commit changes: ${commitResult.error}`
                    );
                }
            } finally {
                // Always clean up temp file
                if (fs.existsSync(commitFile)) {
                    fs.unlinkSync(commitFile);
                }
            }

            // Get commit SHA
            const shaResult = executeGitCommand(
                'git rev-parse HEAD',
                projectPath
            );
            if (!shaResult.success) {
                throw new Error(`Failed to get commit SHA: ${shaResult.error}`);
            }
            const commitSha = shaResult.output || '';

            // Update patch status in database
            await client.query(
                `UPDATE patches
                 SET status = 'applied',
                     applied_at = NOW(),
                     applied_by = $2,
                     merge_commit_sha = $3
                 WHERE id = $1`,
                [patchId, autoMerge ? 'auto-merge' : 'manual', commitSha]
            );

            // Clean up
            fs.unlinkSync(tmpFile);

            return { success: true, mergeCommitSha: commitSha };
        } catch (error) {
            // Clean up temp file
            if (fs.existsSync(tmpFile)) {
                fs.unlinkSync(tmpFile);
            }

            // Check if it's a conflict
            const errorMessage = error.message || String(error);
            if (errorMessage.includes('patch does not apply')) {
                return {
                    success: false,
                    error: 'Patch conflicts with current state',
                };
            }

            return { success: false, error: errorMessage };
        }
    } catch (error) {
        console.error('Error applying patch:', error);
        return { success: false, error: 'Database error' };
    } finally {
        client.release();
    }
}

/**
 * Get patches for a project with risk assessment
 */
export async function getPatchesWithRiskAssessment(
    projectId?: string
): Promise<Array<PatchData & { riskAssessment: PatchRiskAssessment }>> {
    const client = await getDB();

    try {
        let query = `
            SELECT * FROM patches
            WHERE 1=1
        `;
        const params: any[] = [];

        if (projectId) {
            query += ' AND project_id = $1';
            params.push(projectId);
        }

        query += ' ORDER BY created_at DESC LIMIT 100';

        const result = await client.query(query, params);

        // Add risk assessment to each patch
        const patchesWithRisk = await Promise.all(
            result.rows.map(async (patch: PatchData) => {
                // Fetch project to determine if it's generated
                const project = await getProject(patch.project_id);
                const isGenerated = project?.is_generated || false;

                const assessment = assessPatchRisk(patch);

                // Update assessment based on actual project type
                const policies = getMergePolicies();
                const policy = isGenerated
                    ? policies.magiProjects
                    : policies.externalProjects;

                // Re-evaluate auto-merge decision with correct policy
                switch (policy) {
                    case 'none':
                        assessment.canAutoMerge = false;
                        assessment.recommendation =
                            'Manual review required (policy: none)';
                        break;
                    case 'low_risk':
                        assessment.canAutoMerge =
                            assessment.riskLevel === 'low';
                        assessment.recommendation =
                            assessment.riskLevel === 'low'
                                ? 'Safe to auto-merge'
                                : 'Manual review required (risk too high)';
                        break;
                    case 'moderate_risk':
                        assessment.canAutoMerge =
                            assessment.riskLevel === 'low' ||
                            assessment.riskLevel === 'moderate';
                        assessment.recommendation = assessment.canAutoMerge
                            ? 'Can be auto-merged'
                            : 'Manual review required (high/critical risk)';
                        break;
                    case 'all':
                        assessment.canAutoMerge =
                            assessment.riskLevel !== 'critical';
                        assessment.recommendation = assessment.canAutoMerge
                            ? 'Will be auto-merged'
                            : 'Manual review strongly recommended (critical risk)';
                        break;
                }

                return {
                    ...patch,
                    riskAssessment: assessment,
                };
            })
        );

        return patchesWithRisk;
    } catch (error) {
        console.error('Error fetching patches with risk assessment:', error);
        throw error;
    } finally {
        client.release();
    }
}

/**
 * Analyze conflicts for a patch and suggest resolution
 */
export async function analyzePatchConflicts(
    patchId: number,
    projectPath: string
): Promise<{
    hasConflicts: boolean;
    conflictFiles?: string[];
    suggestion?: string;
    error?: string;
    isEmptyRepo?: boolean;
    requiresManualIntervention?: boolean;
}> {
    const client = await getDB();

    try {
        // Validate project path exists
        if (!fs.existsSync(projectPath)) {
            return {
                hasConflicts: false,
                error: `Project directory does not exist: ${projectPath}`,
                requiresManualIntervention: true,
            };
        }

        // Validate it's a git repository
        const gitDir = path.join(projectPath, '.git');
        if (!fs.existsSync(gitDir)) {
            return {
                hasConflicts: false,
                error: `Not a git repository: ${projectPath}`,
                requiresManualIntervention: true,
            };
        }

        // Fetch patch
        const patchResult = await client.query(
            'SELECT * FROM patches WHERE id = $1',
            [patchId]
        );

        if (patchResult.rows.length === 0) {
            throw new Error('Patch not found');
        }

        const patch: PatchData = patchResult.rows[0];

        // Create temporary patch file with random name
        const randomId = crypto.randomBytes(16).toString('hex');
        const tmpFile = path.join(
            '/tmp',
            `patch-${patchId}-check-${randomId}.patch`
        );
        fs.writeFileSync(tmpFile, patch.patch_content, { mode: 0o600 });

        try {
            // Try to apply patch in check mode
            const checkResult = executeGitCommand(
                `git apply --check "${tmpFile}"`,
                projectPath
            );

            if (checkResult.success) {
                // No conflicts
                fs.unlinkSync(tmpFile);
                return { hasConflicts: false };
            } else {
                // Check failed - analyze the error
                const errorOutput = checkResult.error || '';
                const conflictFiles: string[] = [];

                // Analyze error type
                const isActualConflict =
                    errorOutput.includes('patch does not apply') ||
                    errorOutput.includes('error: patch failed') ||
                    errorOutput.includes('Hunk #');
                const isPermissionError =
                    errorOutput.includes('Permission denied');
                const isFormatError =
                    errorOutput.includes('corrupt patch') ||
                    errorOutput.includes('malformed patch');
                const isPathError = errorOutput.includes(
                    'No such file or directory'
                );
                const isEmptyRepoError = errorOutput.includes(
                    'does not exist in index'
                );

                // Handle empty repository as a special case
                if (isEmptyRepoError) {
                    console.log(
                        '[patch-manager] Empty repository detected - patch cannot be applied normally'
                    );
                    if (fs.existsSync(tmpFile)) {
                        fs.unlinkSync(tmpFile);
                    }
                    return {
                        hasConflicts: false,
                        error: errorOutput,
                        isEmptyRepo: true,
                    };
                }

                // If it's not a real conflict, return error
                if (
                    !isActualConflict &&
                    (isPermissionError || isFormatError || isPathError)
                ) {
                    console.log(
                        '[patch-manager] Patch application failed due to non-conflict error'
                    );
                    if (fs.existsSync(tmpFile)) {
                        fs.unlinkSync(tmpFile);
                    }
                    return {
                        hasConflicts: false,
                        error: errorOutput,
                        requiresManualIntervention: true,
                    };
                }

                // Extract file names from error output
                const fileMatches = errorOutput.match(/error: .*?: (.+)/g);
                if (fileMatches) {
                    fileMatches.forEach(match => {
                        const fileMatch = match.match(/: (.+)$/);
                        if (fileMatch) {
                            conflictFiles.push(fileMatch[1]);
                        }
                    });
                }

                // Generate smart conflict resolution suggestion
                let suggestion =
                    'Review and manually resolve conflicts in: ' +
                    conflictFiles.join(', ');

                if (conflictFiles.length > 5) {
                    suggestion = `Multiple files (${conflictFiles.length}) have conflicts. Consider reviewing the patch in smaller chunks.`;
                }

                fs.unlinkSync(tmpFile);
                return {
                    hasConflicts: true,
                    conflictFiles,
                    suggestion,
                };
            }
        } catch (error) {
            console.error('Error analyzing patch conflicts:', error);
            // Clean up temp file if it exists
            if (fs.existsSync(tmpFile)) {
                fs.unlinkSync(tmpFile);
            }
            throw error;
        }
    } catch (error) {
        console.error('Error analyzing patch conflicts:', error);
        throw error;
    } finally {
        client.release();
    }
}

/**
 * Process pending patches for auto-merge based on risk assessment
 */
export async function processPendingPatches(projectId?: string): Promise<{
    processed: number;
    merged: number;
    skipped: number;
    failed: number;
}> {
    const patches = await getPatchesWithRiskAssessment(projectId);

    let processed = 0;
    let merged = 0;
    let skipped = 0;
    let failed = 0;

    // Filter only pending patches
    const pendingPatches = patches.filter(p => p.status === 'pending');

    for (const patch of pendingPatches) {
        processed++;

        if (!patch.riskAssessment.canAutoMerge) {
            console.log(
                `Skipping patch #${patch.id} - ${patch.riskAssessment.recommendation}`
            );
            skipped++;
            continue;
        }

        const projectPath = path.join('/external/host', patch.project_id);

        // Check for conflicts first
        const conflictCheck = await analyzePatchConflicts(
            patch.id,
            projectPath
        );
        if (conflictCheck.hasConflicts) {
            console.log(
                `Skipping patch #${patch.id} - Conflicts detected: ${conflictCheck.suggestion}`
            );
            skipped++;
            continue;
        }

        // Apply the patch
        const result = await applyPatch(patch.id, projectPath, true);

        if (result.success) {
            console.log(
                `Successfully auto-merged patch #${patch.id} (commit: ${result.mergeCommitSha})`
            );
            merged++;
        } else {
            console.error(
                `Failed to auto-merge patch #${patch.id}: ${result.error}`
            );
            failed++;
        }
    }

    return { processed, merged, skipped, failed };
}
