/**
 * Patch Manager Module
 *
 * Handles patch risk assessment, auto-merge decisions, and conflict resolution
 * for code changes generated by MAGI agents.
 */

import { execSync } from 'child_process';
import crypto from 'crypto';
import fs from 'fs';
import path from 'path';
import { getDB } from './db.js';
import { computeMetrics } from '../managers/commit_metrics.js';
import { Metrics } from '../../types/index.js';
import { getDefaultBranch } from './git_utils.js';
import { getProject } from './db_utils.js';

export type MergePolicy = 'none' | 'low_risk' | 'moderate_risk' | 'all';
export type RiskLevel = 'low' | 'moderate' | 'high' | 'critical';

export interface PatchData {
    id: number;
    process_id: string;
    project_id: string;
    branch_name: string;
    commit_message: string;
    patch_content: string;
    metrics?: Metrics;
    status: 'pending' | 'applied' | 'rejected' | 'superseded';
    created_at: Date;
    applied_at?: Date;
    applied_by?: string;
    rejection_reason?: string;
    merge_commit_sha?: string;
}

export interface PatchRiskAssessment {
    riskLevel: RiskLevel;
    riskScore: number;
    canAutoMerge: boolean;
    reasons: string[];
    recommendation: string;
}

/**
 * Get environment-configured merge policies
 */
export function getMergePolicies(): {
    magiProjects: MergePolicy;
    externalProjects: MergePolicy;
} {
    return {
        magiProjects: (process.env.AUTO_MERGE_MAGI_PROJECTS ||
            'all') as MergePolicy,
        externalProjects: (process.env.AUTO_MERGE_EXISTING_PROJECTS ||
            'low_risk') as MergePolicy,
    };
}

/**
 * Get risk thresholds from environment or use defaults
 */
function getRiskThresholds(): { low: number; moderate: number; high: number } {
    return {
        low: parseFloat(process.env.LOW_RISK_MAX || '0.25'),
        moderate: parseFloat(process.env.MOD_RISK_MAX || '0.55'),
        high: parseFloat(process.env.HIGH_RISK_MAX || '0.75'),
    };
}

/**
 * Classify risk score into risk level
 */
export function classifyRiskLevel(riskScore: number): RiskLevel {
    const thresholds = getRiskThresholds();

    if (riskScore <= thresholds.low) return 'low';
    if (riskScore <= thresholds.moderate) return 'moderate';
    if (riskScore <= thresholds.high) return 'high';
    return 'critical';
}

/**
 * Assess the risk of a patch based on its metrics and content
 */
export function assessPatchRisk(patch: PatchData): PatchRiskAssessment {
    const reasons: string[] = [];
    let riskScore = patch.metrics?.score || 0;

    // Additional risk factors specific to patches
    const patchLines = patch.patch_content.split('\n');

    // Check for large patches
    const additions = patchLines.filter(l => l.startsWith('+')).length;
    const deletions = patchLines.filter(l => l.startsWith('-')).length;
    const totalChanges = additions + deletions;

    if (totalChanges > 1000) {
        riskScore += 0.2;
        reasons.push('Very large patch (>1000 lines)');
    } else if (totalChanges > 500) {
        riskScore += 0.1;
        reasons.push('Large patch (>500 lines)');
    }

    // Check for high-risk patterns in patch content
    const dangerousPatterns = [
        { pattern: /DROP\s+TABLE/i, reason: 'Contains DROP TABLE statement' },
        { pattern: /TRUNCATE/i, reason: 'Contains TRUNCATE statement' },
        { pattern: /rm\s+-rf/i, reason: 'Contains rm -rf command' },
        { pattern: /sudo/i, reason: 'Contains sudo command' },
        { pattern: /force\s+push/i, reason: 'Contains force push' },
    ];

    for (const { pattern, reason } of dangerousPatterns) {
        if (pattern.test(patch.patch_content)) {
            riskScore += 0.3;
            reasons.push(reason);
        }
    }

    // Check if patch touches critical files
    const criticalPaths = [
        '.env',
        'docker-compose.yml',
        'package.json',
        'requirements.txt',
        'Gemfile',
        'go.mod',
    ];

    for (const criticalPath of criticalPaths) {
        if (patch.patch_content.includes(`diff --git a/${criticalPath}`)) {
            riskScore += 0.15;
            reasons.push(`Modifies critical file: ${criticalPath}`);
        }
    }

    // Cap risk score at 1.0
    riskScore = Math.min(riskScore, 1.0);

    const riskLevel = classifyRiskLevel(riskScore);

    // Determine if patch can be auto-merged based on policy
    const policies = getMergePolicies();
    const project = patch.project_id; // We'll need to fetch project details

    let canAutoMerge = false;
    let recommendation = '';

    // This will be updated after we fetch project details
    // For now, we'll use a placeholder
    const isGeneratedProject = false; // TODO: Fetch from database
    const policy = isGeneratedProject
        ? policies.magiProjects
        : policies.externalProjects;

    switch (policy) {
        case 'none':
            canAutoMerge = false;
            recommendation = 'Manual review required (policy: none)';
            break;
        case 'low_risk':
            canAutoMerge = riskLevel === 'low';
            recommendation =
                riskLevel === 'low'
                    ? 'Safe to auto-merge'
                    : 'Manual review required (risk too high)';
            break;
        case 'moderate_risk':
            canAutoMerge = riskLevel === 'low' || riskLevel === 'moderate';
            recommendation = canAutoMerge
                ? 'Can be auto-merged'
                : 'Manual review required (high/critical risk)';
            break;
        case 'all':
            canAutoMerge = riskLevel !== 'critical';
            recommendation = canAutoMerge
                ? 'Will be auto-merged'
                : 'Manual review strongly recommended (critical risk)';
            break;
    }

    if (reasons.length === 0 && riskLevel === 'low') {
        reasons.push('Low complexity changes');
    }

    return {
        riskLevel,
        riskScore,
        canAutoMerge,
        reasons,
        recommendation,
    };
}

/**
 * Apply a patch to a project repository
 */
export async function applyPatch(
    patchId: number,
    projectPath: string,
    autoMerge: boolean = false
): Promise<{ success: boolean; error?: string; mergeCommitSha?: string }> {
    const client = await getDB();

    try {
        // Fetch patch from database
        const patchResult = await client.query(
            'SELECT * FROM patches WHERE id = $1 AND status = $2',
            [patchId, 'pending']
        );

        if (patchResult.rows.length === 0) {
            return {
                success: false,
                error: 'Patch not found or already processed',
            };
        }

        const patch: PatchData = patchResult.rows[0];

        // Create temporary patch file with random name
        const randomId = crypto.randomBytes(16).toString('hex');
        const tmpFile = path.join('/tmp', `patch-${patchId}-${randomId}.patch`);
        fs.writeFileSync(tmpFile, patch.patch_content, { mode: 0o600 });

        try {
            // Check if patch can be applied cleanly
            execSync(`git -C "${projectPath}" apply --check "${tmpFile}"`, {
                stdio: 'pipe',
            });

            // Apply the patch
            try {
                execSync(`git -C "${projectPath}" apply "${tmpFile}"`, {
                    stdio: 'pipe',
                });
            } catch (applyError) {
                // If normal apply fails, try with --3way for better merge handling
                console.log(
                    '[patch-manager] Normal apply failed, trying 3-way merge'
                );
                execSync(`git -C "${projectPath}" apply --3way "${tmpFile}"`, {
                    stdio: 'pipe',
                });
            }

            // Stage changes
            execSync(`git -C "${projectPath}" add -A`, {
                stdio: 'pipe',
            });

            // Commit changes with sanitized message
            const sanitizedMessage = patch.commit_message
                .replace(/[^a-zA-Z0-9\s\-_.,!?:;()\[\]{}'"#@/]/g, '')
                .trim()
                .substring(0, 1000);
            const commitMessage = `${sanitizedMessage}\n\nApplied patch #${patchId}`;

            // Use safer approach to avoid command injection
            const commitFile = path.join(
                '/tmp',
                `commit-msg-${patchId}-${Date.now()}.txt`
            );
            fs.writeFileSync(commitFile, commitMessage, { mode: 0o600 });
            try {
                execSync(`git -C "${projectPath}" commit -F "${commitFile}"`, {
                    stdio: 'pipe',
                });
            } finally {
                if (fs.existsSync(commitFile)) {
                    fs.unlinkSync(commitFile);
                }
            }

            // Get commit SHA
            const commitSha = execSync(
                `git -C "${projectPath}" rev-parse HEAD`,
                { encoding: 'utf8' }
            ).trim();

            // Update patch status in database
            await client.query(
                `UPDATE patches 
                 SET status = 'applied',
                     applied_at = NOW(),
                     applied_by = $2,
                     merge_commit_sha = $3
                 WHERE id = $1`,
                [patchId, autoMerge ? 'auto-merge' : 'manual', commitSha]
            );

            // Clean up
            fs.unlinkSync(tmpFile);

            return { success: true, mergeCommitSha: commitSha };
        } catch (error) {
            // Clean up temp file
            if (fs.existsSync(tmpFile)) {
                fs.unlinkSync(tmpFile);
            }

            // Check if it's a conflict
            const errorMessage = error.message || String(error);
            if (errorMessage.includes('patch does not apply')) {
                return {
                    success: false,
                    error: 'Patch conflicts with current state',
                };
            }

            return { success: false, error: errorMessage };
        }
    } catch (error) {
        console.error('Error applying patch:', error);
        return { success: false, error: 'Database error' };
    } finally {
        client.release();
    }
}

/**
 * Get patches for a project with risk assessment
 */
export async function getPatchesWithRiskAssessment(
    projectId?: string
): Promise<Array<PatchData & { riskAssessment: PatchRiskAssessment }>> {
    const client = await getDB();

    try {
        let query = `
            SELECT * FROM patches 
            WHERE 1=1
        `;
        const params: any[] = [];

        if (projectId) {
            query += ' AND project_id = $1';
            params.push(projectId);
        }

        query += ' ORDER BY created_at DESC LIMIT 100';

        const result = await client.query(query, params);

        // Add risk assessment to each patch
        const patchesWithRisk = await Promise.all(
            result.rows.map(async (patch: PatchData) => {
                // Fetch project to determine if it's generated
                const project = await getProject(patch.project_id);
                const isGenerated = project?.is_generated || false;

                const assessment = assessPatchRisk(patch);

                // Update assessment based on actual project type
                const policies = getMergePolicies();
                const policy = isGenerated
                    ? policies.magiProjects
                    : policies.externalProjects;

                // Re-evaluate auto-merge decision with correct policy
                switch (policy) {
                    case 'none':
                        assessment.canAutoMerge = false;
                        assessment.recommendation =
                            'Manual review required (policy: none)';
                        break;
                    case 'low_risk':
                        assessment.canAutoMerge =
                            assessment.riskLevel === 'low';
                        assessment.recommendation =
                            assessment.riskLevel === 'low'
                                ? 'Safe to auto-merge'
                                : 'Manual review required (risk too high)';
                        break;
                    case 'moderate_risk':
                        assessment.canAutoMerge =
                            assessment.riskLevel === 'low' ||
                            assessment.riskLevel === 'moderate';
                        assessment.recommendation = assessment.canAutoMerge
                            ? 'Can be auto-merged'
                            : 'Manual review required (high/critical risk)';
                        break;
                    case 'all':
                        assessment.canAutoMerge =
                            assessment.riskLevel !== 'critical';
                        assessment.recommendation = assessment.canAutoMerge
                            ? 'Will be auto-merged'
                            : 'Manual review strongly recommended (critical risk)';
                        break;
                }

                return {
                    ...patch,
                    riskAssessment: assessment,
                };
            })
        );

        return patchesWithRisk;
    } catch (error) {
        console.error('Error fetching patches with risk assessment:', error);
        throw error;
    } finally {
        client.release();
    }
}

/**
 * Analyze conflicts for a patch and suggest resolution
 */
export async function analyzePatchConflicts(
    patchId: number,
    projectPath: string
): Promise<{
    hasConflicts: boolean;
    conflictFiles?: string[];
    suggestion?: string;
    error?: string;
}> {
    const client = await getDB();

    try {
        // Fetch patch
        const patchResult = await client.query(
            'SELECT * FROM patches WHERE id = $1',
            [patchId]
        );

        if (patchResult.rows.length === 0) {
            throw new Error('Patch not found');
        }

        const patch: PatchData = patchResult.rows[0];

        // Create temporary patch file with random name
        const randomId = crypto.randomBytes(16).toString('hex');
        const tmpFile = path.join(
            '/tmp',
            `patch-${patchId}-check-${randomId}.patch`
        );
        fs.writeFileSync(tmpFile, patch.patch_content, { mode: 0o600 });

        try {
            // Try to apply patch in check mode
            execSync(`git -C "${projectPath}" apply --check "${tmpFile}"`, {
                stdio: 'pipe',
            });

            // No conflicts
            fs.unlinkSync(tmpFile);
            return { hasConflicts: false };
        } catch (error) {
            // Parse conflict information
            const errorOutput = error.stderr?.toString() || error.message;
            const conflictFiles: string[] = [];

            console.log('[patch-manager] Git apply check failed:', errorOutput);

            // Check if this is actually a conflict vs other types of errors
            const isActualConflict =
                errorOutput.includes('patch does not apply') ||
                errorOutput.includes('does not match index') ||
                errorOutput.includes('already exists in working directory');

            // Check for other common non-conflict errors
            const isPermissionError = errorOutput.includes('Permission denied');
            const isFormatError =
                errorOutput.includes('corrupt patch') ||
                errorOutput.includes('malformed patch');
            const isPathError = errorOutput.includes(
                'No such file or directory'
            );
            const isEmptyRepoError = errorOutput.includes(
                'does not exist in index'
            );

            // If it's not a real conflict, return false
            if (
                !isActualConflict &&
                (isPermissionError ||
                    isFormatError ||
                    isPathError ||
                    isEmptyRepoError)
            ) {
                console.log(
                    '[patch-manager] Patch application failed due to non-conflict error'
                );
                if (fs.existsSync(tmpFile)) {
                    fs.unlinkSync(tmpFile);
                }
                return {
                    hasConflicts: false,
                    error: errorOutput,
                };
            }

            // Extract file names from error output
            const fileMatches = errorOutput.match(/error: .*?: (.+)/g);
            if (fileMatches) {
                fileMatches.forEach(match => {
                    const fileMatch = match.match(/: (.+)$/);
                    if (fileMatch) {
                        conflictFiles.push(fileMatch[1]);
                    }
                });
            }

            // Generate suggestion based on conflict type
            let suggestion = 'Manual conflict resolution required. ';

            if (conflictFiles.length > 0) {
                suggestion += `Conflicts detected in: ${conflictFiles.join(', ')}. `;

                // Check if files have been modified since patch creation
                const patchAge =
                    Date.now() - new Date(patch.created_at).getTime();
                const ageInHours = patchAge / (1000 * 60 * 60);

                if (ageInHours > 24) {
                    suggestion +=
                        'This patch is over 24 hours old. Consider regenerating it with the latest changes.';
                } else {
                    suggestion +=
                        'Try pulling latest changes and regenerating the patch, or manually apply the changes.';
                }
            }

            // Clean up
            if (fs.existsSync(tmpFile)) {
                fs.unlinkSync(tmpFile);
            }

            return {
                hasConflicts: isActualConflict,
                conflictFiles,
                suggestion,
            };
        }
    } catch (error) {
        console.error('Error analyzing patch conflicts:', error);
        throw error;
    } finally {
        client.release();
    }
}

/**
 * Process pending patches for auto-merge based on risk assessment
 */
export async function processPendingPatches(projectId?: string): Promise<{
    processed: number;
    merged: number;
    skipped: number;
    failed: number;
}> {
    const patches = await getPatchesWithRiskAssessment(projectId);

    let processed = 0;
    let merged = 0;
    let skipped = 0;
    let failed = 0;

    // Filter only pending patches
    const pendingPatches = patches.filter(p => p.status === 'pending');

    for (const patch of pendingPatches) {
        processed++;

        if (!patch.riskAssessment.canAutoMerge) {
            console.log(
                `Skipping patch #${patch.id} - ${patch.riskAssessment.recommendation}`
            );
            skipped++;
            continue;
        }

        // Get project path
        const projectPath = path.join(
            '/magi_output',
            patch.process_id,
            'projects',
            patch.project_id
        );

        // Check for conflicts first
        const conflictCheck = await analyzePatchConflicts(
            patch.id,
            projectPath
        );
        if (conflictCheck.hasConflicts) {
            console.log(
                `Skipping patch #${patch.id} - Conflicts detected: ${conflictCheck.suggestion}`
            );
            skipped++;
            continue;
        }

        // Apply the patch
        const result = await applyPatch(patch.id, projectPath, true);

        if (result.success) {
            console.log(
                `Successfully auto-merged patch #${patch.id} (commit: ${result.mergeCommitSha})`
            );
            merged++;
        } else {
            console.error(
                `Failed to auto-merge patch #${patch.id}: ${result.error}`
            );
            failed++;
        }
    }

    return { processed, merged, skipped, failed };
}
