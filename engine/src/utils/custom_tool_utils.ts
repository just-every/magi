/**
 * Custom Tool Utilities
 *
 * Utilities for creating, modifying, and managing dynamic tools.
 * Custom tools are created on demand by agents and stored in a database.
 * Each agent only has access to tools it created or that are specifically
 * relevant to its current task.
 */

import * as fs from 'fs';
import * as path from 'path';
import { createToolFunction } from '@just-every/ensemble';
// Import only what we use from model_data.js
import { getHelperDescriptions } from './tool_context.js';
import { quick_llm_call } from './llm_call_utils.js';
import {
    ensembleEmbed,
    ToolParameterType,
    ToolFunction,
} from '@just-every/ensemble';
import {
    CustomTool,
    addCustomTool,
    getCustomToolByName,
    searchCustomToolsByEmbedding,
} from './db_utils.js';
import { get_working_dir } from './file_utils.js';
import { executeToolInSandbox } from './tool_executor.js';
import { sendStreamEvent } from './communication.js';
import { v4 as uuidv4 } from 'uuid';
import type { ToolCall } from 'openai/resources/beta/threads/runs/steps.js';

/**
 * Represents a tool generated by the CodeAgent
 */
interface GeneratedTool {
    name: string; // e.g., "translate_text"
    description: string; // plain-language description
    parameters_json: object; // JSON schema
    implementation: string; // TypeScript function body as string
}

// Import the tool executor for consistent execution of both tools and scripts

// Maximum size of feedback message to prevent prompt size explosion
const MAX_FEEDBACK_SIZE = 2500;

// Maximum number of custom tools an agent can have to prevent overwhelming the agent
export const MAX_AGENT_TOOLS = 20;

// Cache generated tools to avoid unnecessary DB lookups during a session
const toolCache = new Map<string, ToolFunction>();

// Per-agent cache of custom tools
// Keys are agent_ids, values are arrays of custom tool functions
export const agentToolCache = new Map<string, ToolFunction[]>();

/**
 * Adds or updates a tool in the specified agent's tool cache.
 * Enforces MAX_AGENT_TOOLS limit.
 *
 * @param agent_id The ID of the agent.
 * @param toolFunction The ToolFunction to add or update.
 */
function addOrUpdateToolInAgentCache(
    agent_id: string,
    toolFunction: ToolFunction
): void {
    if (!agent_id) return; // Do nothing if no agent_id

    // Initialize the agent's tool cache if needed
    if (!agentToolCache.has(agent_id)) {
        agentToolCache.set(agent_id, []);
    }

    const agentToolsInCache = agentToolCache.get(agent_id)!;

    // Check if this tool already exists in the agent's toolset by name
    const existingIndexInCache = agentToolsInCache.findIndex(
        tf =>
            tf.definition.function.name ===
            toolFunction.definition.function.name
    );

    if (existingIndexInCache >= 0) {
        // Replace with newer version if it already exists
        agentToolsInCache[existingIndexInCache] = toolFunction;
    } else {
        // Add new tool, enforcing MAX_AGENT_TOOLS
        if (agentToolsInCache.length >= MAX_AGENT_TOOLS) {
            agentToolsInCache.shift(); // Remove the oldest tool
        }
        agentToolsInCache.push(toolFunction);
    }
}

// No need for forward declarations, we'll just move these functions up in the file

/**
 * Retrieve basic custom tool creation functions
 * This function returns only the CUSTOM_TOOL function.
 * @returns An array of custom tool functions
 */
export function getCustomTools(): ToolFunction[] {
    return [
        createToolFunction(CUSTOM_TOOL, 'Solve a problem with a custom tool.', {
            problem: {
                type: 'string',
                description: 'What problem does this tool need to solve?',
            },
            input: {
                type: 'string',
                description:
                    'Either a string, or JSON object (stringified) which contains all the information needed by the tool to solve the problem. This input will be run once the tool is created. It will also be used as a guide for the input parameters for future uses of the tool.',
            },
            result: {
                type: 'string',
                description:
                    'What should this tool return, or what task should it perform?',
            },
            force_new: {
                type: 'boolean',
                description:
                    'Set to true to skip existing tool matches and force creation of a new tool.',
                default: false,
            },
        }),
    ];
}

/**
 * Get agent-specific tools for a particular agent
 *
 * @param agent_id The ID of the agent to get tools for
 * @returns Array of tool functions specific to this agent
 */
export function getAgentSpecificTools(agent_id: string): ToolFunction[] {
    const tools: ToolFunction[] = [];

    // Add modify_tool only if this agent has custom tools
    if (
        agentToolCache.has(agent_id) &&
        agentToolCache.get(agent_id)!.length > 0
    ) {
        tools.push(
            createToolFunction(
                modify_tool,
                'Modify an existing custom tool. This will create a new version of the tool with the changes.',
                {
                    name: {
                        type: 'string',
                        description: 'The name of the existing tool to modify.',
                    },
                    modification_request: {
                        type: 'string',
                        description:
                            'Description of the changes to make to the tool.',
                    },
                },
                'The modified tool with the requested changes.'
            )
        );
    }

    // Add any cached tools for this agent
    if (agentToolCache.has(agent_id)) {
        tools.push(...agentToolCache.get(agent_id)!);
    }

    return tools;
}

/**
 * Get relevant custom tools based on embedding similarity to a query
 * @param embedding The embedding vector to use for similarity search
 * @param threshold Similarity threshold (default: 0.7)
 * @param limit Maximum number of tools to return (default: 3)
 * @returns Array of tool functions that match the embedding
 */
export async function getRelevantCustomTools(
    embedding: number[],
    threshold: number = 0.7,
    limit: number = 3
): Promise<ToolFunction[]> {
    try {
        // Search database for similar tools
        const similarTools = await searchCustomToolsByEmbedding(
            embedding,
            threshold,
            limit
        );

        // Convert DB tools to ToolFunction objects
        return similarTools.map(tool => convertCustomToolToToolFunction(tool));
    } catch (error) {
        console.error('Error fetching relevant custom tools:', error);
        return [];
    }
}

/**
 * Use an LLM to pick the most appropriate tool from a list of candidate tools
 * based on a problem description.
 *
 * @param problem The description of the problem to solve
 * @param candidateTools Array of potential tools that might solve the problem
 * @returns The best matching tool or null if none are suitable
 */
async function llmPickBestTool(
    problem: string,
    candidateTools: CustomTool[]
): Promise<CustomTool | null> {
    if (candidateTools.length === 0) {
        return null;
    }

    console.log(
        `Using LLM to rank ${candidateTools.length} tool candidates for: ${problem}`
    );

    // Prepare the prompt with tool information
    let toolsDescription = '';
    for (let i = 0; i < candidateTools.length; i++) {
        const tool = candidateTools[i];
        toolsDescription += `[${i + 1}] ${tool.name}
Description: ${tool.description}
Parameters: ${tool.parameters_json}\n\n`;
    }

    // Call the LLM to select the best tool or "none"
    const response = await quick_llm_call(
        `PROBLEM: ${problem}\n\nBelow is a list of existing tools (name, description, parameters). If one of them clearly solves the problem, return its name. Otherwise return "none".\n\nTOOLS:\n${toolsDescription}`,
        'reasoning_mini',
        {
            name: 'ToolSelectorAgent',
            description:
                'Select the best tool for a given problem, or "none" if no suitable tool exists',
            instructions: `You are evaluating a set of custom tools to determine if any are well-suited to solve a specific problem.

Your task is to carefully analyze the problem description and the list of available tools. For each tool, consider:
1. Does it solve the core functionality requested in the problem?
2. Does it accept the appropriate parameters needed for this problem?
3. Is it likely to produce output that matches what the problem requires?

Return ONLY:
- The exact name of the best tool if one is clearly suitable (e.g., "weather_forecast" or "pdf_extractor")
- The string "none" (lowercase) if no tool is suitable or if you're uncertain

IMPORTANT: Do not return explanations or additional text, only the tool name or "none".
Be strict in your evaluation - only return a tool name if it's truly appropriate for the specific problem.`,
            modelSettings: {
                temperature: 0.2, // Lower temperature for more deterministic selection
                max_tokens: 20, // We only need a short output - just the tool name or "none"
            },
        }
    );

    // Process the response
    const selectedToolName = response.trim().toLowerCase();

    // If the response is "none" or doesn't match any tool name, return null
    if (selectedToolName === 'none') {
        console.log('LLM determined no suitable tool exists for this problem');
        return null;
    }

    // Find the tool that matches the selected name
    const selectedTool = candidateTools.find(
        tool => tool.name.toLowerCase() === selectedToolName
    );

    if (selectedTool) {
        console.log(`LLM selected tool: ${selectedTool.name}`);
        return selectedTool;
    } else {
        // Tool name returned by LLM doesn't match any candidate
        console.log(
            `LLM returned "${selectedToolName}" which doesn't match any candidate tool names`
        );
        return null;
    }
}

/**
 * Helper function to infer a parameter schema from a sample input
 * @param sample The sample input string
 * @returns A JSON schema object defining the parameters
 */
/**
 * Maps JavaScript types to ToolParameterType values
 * @param value Value to determine the type for
 * @returns ToolParameterType string
 */
function getParameterType(value: any): ToolParameterType {
    if (value === null) return 'string'; // Treat null as string type
    if (Array.isArray(value)) return 'array';

    // Standard JS types that match ToolParameterType
    const jsType = typeof value;
    if (jsType === 'string') return 'string';
    if (jsType === 'number') return 'number';
    if (jsType === 'boolean') return 'boolean';

    // Default for objects and anything else
    return 'object';
}

/**
 * Convert a string to snake_case
 * @param str The string to convert
 * @returns The snake_case version of the string
 */
function toSnakeCase(str: string): string {
    return (
        str
            // Handle camelCase
            .replace(/([a-z])([A-Z])/g, '$1_$2')
            // Handle PascalCase
            .replace(/([A-Z])([A-Z][a-z])/g, '$1_$2')
            // Replace spaces, hyphens, and dots with underscores
            .replace(/[\s-]+|\.+/g, '_')
            // Convert to lowercase
            .toLowerCase()
    );
}

/**
 * Infer a parameter schema from a sample input
 * Converting property names to snake_case for consistency
 * @param sample The sample input string
 * @returns A JSON schema object defining the parameters
 */
function inferSchemaFromSample(sample: string): object {
    try {
        const obj = JSON.parse(sample);

        // Create a mapping from original keys to snake_case keys
        const keyMapping = Object.keys(obj).reduce(
            (map, key) => {
                map[key] = toSnakeCase(key);
                return map;
            },
            {} as Record<string, string>
        );

        // Store the mapping as a property in the schema for later use
        const schema = {
            type: 'object',
            properties: Object.fromEntries(
                Object.keys(obj).map(k => [
                    keyMapping[k],
                    {
                        type: getParameterType(obj[k]),
                        description: `The ${k} parameter`,
                        originalName: k, // Store original name for mapping
                    },
                ])
            ),
            required: Object.keys(obj).map(k => keyMapping[k]),
            // Add the key mapping to the schema for use in prepareArguments
            keyMapping: keyMapping,
        };

        return schema;
    } catch {
        // Not JSON, use a single string parameter
        return {
            type: 'object',
            properties: {
                input: {
                    type: 'string',
                    description: 'Input string to process',
                },
            },
            required: ['input'],
        };
    }
}

/**
 * Unified resolver for tool specifications
 * Handles both new tool creation and tool modification cases
 *
 * @param params Configuration parameters for the specification resolution
 * @returns Promise resolving to a tool spec including adapted parameter values
 */
async function _resolveToolSpecification(params: {
    problemDescription: string; // For new: problem; For modify: modification_request
    sampleInputForNewTool?: string; // Original input string, only for new tools
    initialSchemaForNewToolJson?: string; // JSON.stringify(inferSchemaFromSample(input)), only for new tools
    desiredResultForNewTool?: string; // Original result string, only for new tools
    existingToolSpec?: {
        // Only for modifications
        name: string;
        description: string;
        parameters_json: object; // Parsed JSON, not string
    };
}): Promise<{
    name: string;
    description: string;
    parameters_json: object;
    final_parameter_values: object;
}> {
    // Determine whether this is a new tool or modification
    const isModification = !!params.existingToolSpec;

    // Set up the context for the LLM call
    let promptContext = '';
    if (isModification) {
        promptContext = `CONTEXT: "You are modifying an existing tool specification."
MODIFICATION REQUEST: ${params.problemDescription}
EXISTING TOOL NAME: ${params.existingToolSpec!.name}
EXISTING TOOL DESCRIPTION: ${params.existingToolSpec!.description}
EXISTING TOOL PARAMETERS (JSON): ${JSON.stringify(params.existingToolSpec!.parameters_json, null, 2)}`;
    } else {
        promptContext = `CONTEXT: "You are creating a brand new tool specification."
PROBLEM: ${params.problemDescription}
SAMPLE INPUT: ${params.sampleInputForNewTool}
INITIAL INFERRED SCHEMA: ${params.initialSchemaForNewToolJson}
DESIRED RESULT: ${params.desiredResultForNewTool}`;
    }

    // Call the LLM to generate the specification
    const response = await quick_llm_call(
        promptContext, // Pass the dynamically assembled context
        null,
        {
            name: 'SpecificationAgent',
            description:
                'Generate or modify a tool specification based on the problem and context.',
            instructions: `You are designing a tool specification. Based on the provided information, your goal is to define a robust and potentially more useful tool.

YOUR PLAN:
1. **Analyze:** Please think through the intent of the tool and consider the underlying problem it is trying to solve. ${
                isModification
                    ? 'The existing specification may be sufficient, but consider if the modification request implies a need for generalization.'
                    : 'The provided schema may be the best option, but if you can think of a more general or useful version of the tool, please do so.'
            }
Do not go too far from the original schema - ${
                isModification
                    ? "the existing tool's functionality should still be preserved with the requested changes."
                    : 'the provided input should still work with minor modifications.'
            }

2. **Name & Description (name, description):** ${
                isModification
                    ? "Update or keep the name and description based on the modification request. Only change the name if there's a clear need for generalization or it's explicitly requested."
                    : "Propose a concise, descriptive snake_case name and a clear description for the tool, based on your final analysis. If the initial request is very specific (e.g., 'screenshot yahoo.com'), consider if a more general name (e.g., 'take_website_screenshot') is appropriate."
            }

3. **Parameters Schema (parameters_json):** Define the JSON schema for the tool's parameters. This schema should support the final version of the tool. ${
                isModification
                    ? 'Update the parameters as needed based on the modification request. Consider if new parameters are needed or existing ones should be changed.'
                    : "For instance, if the sample input implies a hardcoded URL, your schema should likely include a 'url' parameter. If you do not need to generalize the schema, you can use the initial schema as is."
            }

4. **Adapted Parameter Values (final_parameter_values):** This is critical. Create an object where keys are the parameter names from YOUR proposed parameters_json, and values are the specific values ${
                isModification
                    ? 'that would be needed to test the modified tool based on the modification request.'
                    : "extracted or inferred from the original SAMPLE_INPUT that would allow the generalized tool to fulfill the original specific request. (e.g., if your schema has 'url' and 'filepath', and sample input was for Yahoo, final_parameter_values might be {'url': 'https://yahoo.com', 'filepath': 'default_path.png'})."
            }

${
    isModification
        ? "If the modification doesn't change the parameter schema, simply provide values that would be suitable for testing the modified version."
        : 'If no generalization seems necessary, you can refine the initial input schema and still provide final_parameter_values based on the original input.'
}

WARNING:
DO NOT generalize the function so far that you cannot infer the correct final parameter values. The goal is to create a tool that can be used in the future with different inputs, but still works for the original request or with the requested modifications.

RESULT:
Return ONLY valid JSON containing name, description, parameters_json, and final_parameter_values.`,
            modelClass: 'reasoning_mini',
            modelSettings: {
                json_schema: {
                    name: 'tool_specification',
                    type: 'json_schema',
                    schema: {
                        type: 'object',
                        properties: {
                            name: {
                                type: 'string',
                                description:
                                    'snake_case name of the tool - up to 6 words - be descriptive',
                            },
                            description: {
                                type: 'string',
                                description:
                                    'A couple of sentences describing what the tool does. Focus on the input and output. A couple of sentences is enough.',
                            },
                            parameters_json: {
                                type: 'object',
                                description:
                                    'The JSON schema for the tool parameters, potentially generalized beyond the original sample input. You may add new parameters or modify existing ones.',
                            },
                            final_parameter_values: {
                                type: 'object',
                                description:
                                    'An object mapping the parameter names from parameters_json to specific values derived from the original sample input or modification request.',
                            },
                        },
                        required: [
                            'name',
                            'description',
                            'parameters_json',
                            'final_parameter_values',
                        ],
                    },
                },
            },
        }
    );

    try {
        // Parse the response
        const spec = JSON.parse(response);

        // Validate the spec has all required fields
        if (
            !spec.name ||
            !spec.description ||
            !spec.parameters_json ||
            !spec.final_parameter_values
        ) {
            throw new Error(
                'Generated specification is missing required fields'
            );
        }

        // Return the full specification with adapted parameter values
        return {
            name: spec.name,
            description: spec.description,
            parameters_json: spec.parameters_json,
            final_parameter_values: spec.final_parameter_values,
        };
    } catch (error) {
        console.error('Error parsing tool spec:', error);
        throw new Error(
            `Failed to generate valid tool specification: ${error instanceof Error ? error.message : String(error)}`
        );
    }
}

/**
 * Generate a tool specification (name, description, parameters)
 * Leverages an LLM to create a potentially generalized tool based on the problem description,
 * sample input, and desired result. The returned specification includes adapted parameter values
 * to test the tool with the original request.
 *
 * @param problem Description of the problem to solve
 * @param input Sample input
 * @param result Description of expected result
 * @returns Promise resolving to a tool spec and adapted parameter values
 */
async function generateToolSpec(
    problem: string,
    input: string,
    result: string
): Promise<{
    name: string;
    description: string;
    parameters_json: object;
    final_parameter_values: object;
}> {
    // Infer parameter schema from the sample input first
    const inferredSchema = inferSchemaFromSample(input);
    const prettyParams = JSON.stringify(inferredSchema, null, 2);

    // Use the unified resolver for new tool specifications
    return _resolveToolSpecification({
        problemDescription: problem,
        sampleInputForNewTool: input,
        initialSchemaForNewToolJson: prettyParams,
        desiredResultForNewTool: result,
    });
}

/**
 * Generates and validates a tool implementation
 * This internal helper function is used by both CUSTOM_TOOL and modify_tool
 * to avoid code duplication between the two.
 *
 * @param toolSpec The specification of the tool to generate/validate
 * @param agent_id The agent ID
 * @param problem The problem description (for new tools) or modification request (for modifications)
 * @param input Sample input for testing the tool
 * @param result Expected result description
 * @param existingImplementation Optional existing implementation (for modify_tool)
 * @param feedback Optional feedback from previous attempt
 * @param maxAttempts Maximum number of generation attempts
 * @returns A Promise resolving to the generated tool object or null if failed
 */
async function _generateAndValidateImplementation(
    toolSpec: {
        name: string;
        description: string;
        parameters_json: object;
    },
    agent_id: string,
    problem: string,
    input: string,
    result: string,
    existingImplementation?: string,
    feedback?: string | null,
    maxAttempts: number = 10
): Promise<GeneratedTool | null> {
    let attempts = 0;
    let executionResult: string | null = null;
    // No need to track separately, we'll return the output directly

    // Get the parameter keys from the toolSpec
    const paramKeys = Object.keys(
        (toolSpec.parameters_json as any).properties || {}
    );

    // Generate and test the implementation with multiple attempts if needed
    while (attempts < maxAttempts) {
        attempts++;
        console.log(`Tool generation attempt ${attempts}/${maxAttempts}`);

        // Build prompt for CodeAgent to implement the function
        const prettyParams = JSON.stringify(toolSpec.parameters_json, null, 2);

        const absolutePath = path.join(
            get_working_dir(),
            `${toolSpec.name}_${attempts}.ts`
        );

        // Build the code prompt, instructing Claude to:
        // 1. Save to a file named after the tool
        // 2. Use the right function signature
        // 3. Output the filename as the last line
        let codePrompt = `Please create a TypeScript function that implements the following specification:
NAME: ${toolSpec.name}
DESCRIPTION: ${toolSpec.description}
PARAMETERS
${prettyParams}

---
HELPER FUNCTIONS - The following TypeScript declarations define helper functions available in the global scope:

${getHelperDescriptions().join('\n\n')}

---
SPECIFICATION - Your tool implementation MUST follow this SPECIFICATION:

/**
 * ${toolSpec.description}
 *
 * @param ${paramKeys.length > 0 ? paramKeys.join(' Description of first parameter\\n * @param ') : ''}${paramKeys.length > 0 ? ' Description of last parameter' : ''}
 * @returns Promise<string>
 */
export async function ${toolSpec.name}(${paramKeys.length > 0 ? paramKeys.map(key => `${key}: ${(toolSpec.parameters_json as any).properties[key]?.type || 'any'}`).join(', ') : ''}): Promise<string> {
    // Your implementation here
    return 'Final status or result';
}

---
EXAMPLE IMPLEMENTATION

\`\`\`typescript
// If you need to use Node.js built-in modules directly, you can import them:
import fs from 'fs';

// For all helper functions like read_file and quick_llm_call, no import is needed as they are globally available
// Include the TypeScript declaration of all helper functions you'll use at the top of your file for type-safety and linting
declare function read_file(
    file_path: string,
    line_start?: number,
    line_end?: number,
    max_chars?: number
): Promise<string>;

declare function quick_llm_call(
    messages: string | Array<{ type: 'message'; role: 'user' | 'system' | 'developer'; content: string }>,
    modelClass: 'reasoning_mini' | 'reasoning' | 'code' | 'writing' | 'summary' | 'vision' | 'image_generation',
): Promise<string>;

/**
 * An example implementation of using tools to summarize a file
 *
 * @param filePath string The path to the file to summarize
 * @returns Promise<string> containing the result
 */
export async function example_file_summary(filePath: string): Promise<string> {
    // EXAMPLE: Reading a file using the read_file helper function
    let fileContent = '';
    try {
        fileContent = await read_file(filePath);
        console.log(\`File \${filePath} content length:\`, fileContent.length);
    }
    catch (error) {
        // You can return errors as strings or throw them
        return \`ERROR could not read file \${filePath}: \${error}\`;
    }

    // EXAMPLE: Using an LLM to process content
    const llmResponse = await quick_llm_call('Summarize this document: '+fileContent, 'summary');
    const llmSummary = llmResponse.substring(0, 100);
    // errors throw will be handled automatically by the tool executor

    // EXAMPLE: Using node.js modules
    fs.unlink(filePath, () => {});

    return llmSummary;  // Always return a string
}
\`\`\`

---
FILE OUTPUT REQUIREMENT:
You MUST write your complete function implementation to a file located at ${absolutePath}`;

        if (feedback) {
            codePrompt += `

---
TEST FAILURE:
Another agent previously attempted to implement this function, but it failed. Here is the feedback from that attempt:
\`\`\`
${feedback}
\`\`\`

Please fix the code based on this feedback. If you need to re-rewrite the entire function, please do so.`;
        }

        // Add previous implementation and feedback if available
        if (existingImplementation) {
            codePrompt += `

---
FAILED CODE:
This is the existing implementation, which needs to be modified:
\`\`\`typescript
${existingImplementation}
\`\`\``;
        }

        // Prepare the arguments for passing through environment variables
        let orderedArgsForCli: any[] = []; // Changed from string[] to any[] to hold raw values
        try {
            const finalParamsObject = JSON.parse(input); // 'input' is adaptedInputString from final_parameter_values

            if (
                paramKeys.length > 0 &&
                (typeof finalParamsObject !== 'object' ||
                    finalParamsObject === null)
            ) {
                // This case implies that paramKeys exist, but the input (final_parameter_values)
                // is not an object that can provide these keys. This might happen if the schema
                // expects e.g. { "input_string": "value" } but final_parameter_values was just "value".
                // If there's only one paramKey, assume finalParamsObject is its direct value.
                if (paramKeys.length === 1) {
                    // Don't stringify individual values - we'll stringify the entire array once
                    orderedArgsForCli.push(finalParamsObject); // Push raw value
                } else {
                    // Multiple params expected, but input is not an object. This is ambiguous.
                    // Fallback to old behavior for safety, though this state indicates an upstream issue.

                    console.warn(
                        'CLI Warning: Params expected by schema, but final_parameter_values not an object. Input: ' +
                            input
                    ); // Ensure single quotes
                    throw new Error(
                        'Ambiguous input for CLI test string with multiple parameters.'
                    );
                }
            } else if (
                typeof finalParamsObject === 'object' &&
                finalParamsObject !== null
            ) {
                for (const key of paramKeys) {
                    // paramKeys are from the schema. finalParamsObject is from LLM-generated final_parameter_values.
                    // It's assumed keys in finalParamsObject align with paramKeys.
                    const value = Object.prototype.hasOwnProperty.call(
                        finalParamsObject,
                        key
                    )
                        ? finalParamsObject[key]
                        : undefined;
                    // Don't stringify individual values - we'll stringify the entire array once
                    orderedArgsForCli.push(value); // Push raw value
                }
            }
            // If paramKeys is empty, orderedArgsForCli will be empty.
            // If finalParamsObject was not an object and paramKeys was also empty, it's also fine.
        } catch (e) {
            // Fallback if JSON.parse(input) fails or other issues.
            // This is a safety net; 'input' should be valid JSON from final_parameter_values.
            console.warn(
                "Could not construct args array from input '" +
                    input +
                    "' due to: " +
                    (e instanceof Error ? e.message : String(e)) +
                    '. Falling back to raw input string.'
            );
            orderedArgsForCli = [input]; // Use the raw input string directly (without quotes)
        }

        // Store original environment variables to restore later
        const originalEnv = {
            MAGI_TEST_AGENT_ID: process.env.MAGI_TEST_AGENT_ID,
            MAGI_TEST_FILE_PATH: process.env.MAGI_TEST_FILE_PATH,
            MAGI_TEST_FUNCTION_NAME: process.env.MAGI_TEST_FUNCTION_NAME,
            MAGI_TEST_ARGS_JSON: process.env.MAGI_TEST_ARGS_JSON,
        };

        // Set environment variables for the test
        console.log(
            '[custom_tool_utils] Setting test environment variables for CodeAgent'
        );
        process.env.MAGI_TEST_AGENT_ID = agent_id;
        process.env.MAGI_TEST_FILE_PATH = absolutePath;
        process.env.MAGI_TEST_FUNCTION_NAME = toolSpec.name;
        process.env.MAGI_TEST_ARGS_JSON = JSON.stringify(orderedArgsForCli);

        codePrompt += `

---
SCRIPTS & TESTING:
ALWAYS test your implementation by running the following command:
> test-custom-tool.sh

IMPORTANT: This testing tool requires that you create a named export function:
export async function ${toolSpec.name}(...) {
  // Your implementation
}

---
PLAN:
1. Think through the problem fully and consider the full intent of the request.
2. Write the full async TypeScript function implementation for this tool.
3. You MUST save your final code as a single file located at ${absolutePath}
4. TEST, TEST, TEST using \`test-custom-tool.sh\`
- fix any issues and resolve the underlying problem, never add mock code or placeholders.
5. Make the VERY LAST LINE of your output only the string '[complete]'

WARNINGS:
Please ensure that your function solves the intent of the problem and works for general cases, not just the sample input provided.
Where possible, test your function before returning it. Do not return mock code or placeholders. If you encounter any issues, please explain the underlying issue.

FAILURE:
If you determine that this task cannot be completed, instead of providing code, respond with ONLY:
ERROR: <clear explanation of why the task cannot be completed>`;

        const codeMessage = `
PROBLEM TO SOLVE:
${problem}

SAMPLE INPUT:
${input}

DESIRED RESULT:
${result}

WARNING:
**Never, ever, ever include mock code or placeholders!**
Mock code and placeholders are not acceptable. They can cause confusion and lead to tests passing when they should fail. It's important we know when the tool is failing, so if you are not able to handle certain cases, please explain the underlying issue and return an error message instead of mock code.
Always attempt to solve the problem fully, even if it requires multiple iterations.`;

        console.log(`\n\n***Code prompt for CodeAgent:\n${codePrompt}`);
        console.log(`\n\n***Code message for CodeAgent:\n${codeMessage}`);

        // Generate the implementation
        let response;
        try {
            response = await quick_llm_call(
                codeMessage,
                null,
                {
                    name: 'CustomToolAgent',
                    description:
                        'Generate a TypeScript function implementation for a custom tool.',
                    instructions: codePrompt,
                    modelClass: 'code',
                },
                agent_id
            );
        } finally {
            // Clean up environment variables after CodeAgent completes
            console.log(
                '[custom_tool_utils] Cleaning up test environment variables'
            );
            if (originalEnv.MAGI_TEST_AGENT_ID === undefined) {
                delete process.env.MAGI_TEST_AGENT_ID;
            } else {
                process.env.MAGI_TEST_AGENT_ID = originalEnv.MAGI_TEST_AGENT_ID;
            }

            if (originalEnv.MAGI_TEST_FILE_PATH === undefined) {
                delete process.env.MAGI_TEST_FILE_PATH;
            } else {
                process.env.MAGI_TEST_FILE_PATH =
                    originalEnv.MAGI_TEST_FILE_PATH;
            }

            if (originalEnv.MAGI_TEST_FUNCTION_NAME === undefined) {
                delete process.env.MAGI_TEST_FUNCTION_NAME;
            } else {
                process.env.MAGI_TEST_FUNCTION_NAME =
                    originalEnv.MAGI_TEST_FUNCTION_NAME;
            }

            if (originalEnv.MAGI_TEST_ARGS_JSON === undefined) {
                delete process.env.MAGI_TEST_ARGS_JSON;
            } else {
                process.env.MAGI_TEST_ARGS_JSON =
                    originalEnv.MAGI_TEST_ARGS_JSON;
            }
        }

        // Extract the implementation from the file written by Claude
        try {
            // Resolve the file path relative to the current working directory
            console.log(`Looking for file at: ${absolutePath}`);

            // Check if the file exists
            if (!fs.existsSync(absolutePath)) {
                throw new Error(
                    `Implementation file not found: ${absolutePath}`
                );
            }

            // Read the file content
            let implementation = fs.readFileSync(absolutePath, 'utf-8');

            // Auto-fix common issues with the implementation

            // 1. Check if 'export' is missing from the main function
            const functionName = toolSpec.name;
            const functionRegex = new RegExp(
                `(async\\s+)?function\\s+${functionName}\\s*\\(`
            );
            const exportRegex = new RegExp(
                `export\\s+(async\\s+)?function\\s+${functionName}\\s*\\(`
            );

            if (
                implementation.match(functionRegex) &&
                !implementation.match(exportRegex)
            ) {
                console.log(
                    `[custom_tool_utils] Attempting to add missing 'export' for function ${functionName}`
                );
                implementation = implementation.replace(
                    new RegExp(
                        `(async\\s+)?function\\s+${functionName}\\s*\\(`
                    ),
                    `export $1function ${functionName}(`
                );
            }

            // 2. Check if 'async' is missing but the function returns a Promise
            const promiseReturnRegex = new RegExp(
                `(export\\s+)?function\\s+${functionName}\\s*\\([^)]*\\)\\s*:\\s*Promise<`
            );
            const asyncRegex = new RegExp(
                `(export\\s+)?async\\s+function\\s+${functionName}`
            );

            if (
                implementation.match(promiseReturnRegex) &&
                !implementation.match(asyncRegex)
            ) {
                console.log(
                    `[custom_tool_utils] Attempting to add missing 'async' for function ${functionName}`
                );
                implementation = implementation.replace(
                    new RegExp(`(export\\s+)?function\\s+${functionName}`),
                    `$1async function ${functionName}`
                );
            }

            // 3. Strict validation - verify the function exists with correct name after fixes
            const expectedFunctionRegex = new RegExp(
                `export\\s+(async\\s+)?function\\s+${functionName}\\s*\\(`
            );
            if (!implementation.match(expectedFunctionRegex)) {
                console.log(
                    `[custom_tool_utils] Warning: Function '${functionName}' still not found with expected signature after fixes`
                );
                // Don't fail here - we'll let the execution attempt determine if it's a problem
            }

            // Validate that it contains a function definition
            if (
                !implementation.includes('function') ||
                !implementation.includes(toolSpec.name)
            ) {
                throw new Error(
                    'Implementation file does not contain a valid function definition'
                );
            }

            console.log(
                `Successfully read implementation from file: ${absolutePath}`
            );

            // Extract parameter names and verify they match the schema
            const funcParams = extractParameterNames(implementation);

            // Verify that all required parameters are present in the function signature
            const missingParams = paramKeys.filter(
                key => !funcParams.includes(key)
            );

            if (missingParams.length > 0) {
                throw new Error(
                    `Function signature is missing parameters: ${missingParams.join(', ')}`
                );
            }

            // Create a temporary tool object
            const generatedTool: GeneratedTool = {
                name: toolSpec.name,
                description: toolSpec.description,
                parameters_json: toolSpec.parameters_json,
                implementation: implementation,
            };

            // Prepare arguments by mapping to parameter names, using the parameter schema
            const args = prepareArguments(
                implementation,
                input,
                toolSpec.parameters_json
            );

            const toolCall: ToolCall = {
                id: uuidv4(),
                type: 'function',
                function: {
                    name: toolSpec.name,
                    arguments: JSON.stringify(args),
                    output: null,
                },
            };

            const verifierAgentDefinition = {
                agent_id: uuidv4(),
                name: 'VerifierAgent',
                parent_id: agent_id,
            };

            sendStreamEvent({
                type: 'agent_start',
                agent: verifierAgentDefinition,
            });

            sendStreamEvent({
                type: 'tool_start',
                tool_call: toolCall,
                agent: verifierAgentDefinition,
            });

            // Execute the function in a safe sandbox with the agent context
            console.log(`Testing tool '${toolSpec.name}' with sample input...`);
            executionResult = await executeToolInSandbox({
                codeString: implementation,
                functionName: toolSpec.name,
                agentId: agent_id || '',
                args: args,
            });

            sendStreamEvent({
                type: 'tool_done',
                tool_call: toolCall,
                result: executionResult,
                agent: verifierAgentDefinition,
            });

            console.log(`Tool execution result: ${executionResult}`);

            // Use quick_llm_call with reasoning_mini to verify the result
            const verifierResult = await quick_llm_call(
                `PROBLEM: ${problem}

SAMPLE INPUT: ${input}

EXPECTED RESULT DESCRIPTION: ${result}

ACTUAL RESULT: ${executionResult}`,
                null,
                {
                    ...verifierAgentDefinition,
                    description:
                        'Verify if the tool execution result meets expectations.',
                    instructions: `You are verifying if a TypeScript tool's execution result satisfies the expected outcome.
Does the actual result satisfy the intent of result description? Do not be overly strict, but fail will not solve the intent of problem.
Return only
"pass" if it satisfies expectations, or "fail: <reason>" explaining why it doesn't.
`,

                    modelClass: 'reasoning_mini',
                    modelSettings: {
                        temperature: 0.5, // Lower temperature for more deterministic evaluation
                    },
                },
                agent_id
            );

            // Check if the tool passed verification
            if (verifierResult.trim().toLowerCase().startsWith('pass')) {
                console.log('Tool verification passed!');
                // Success! Return the generated tool
                return generatedTool;
            } else {
                // Extract the reason for failure
                const failReason = verifierResult
                    .replace(/^fail:\s*/i, '')
                    .trim();
                console.log('Tool verification failed: ' + failReason);

                // Truncate feedback to prevent prompt explosion
                feedback = `Testing the tool failed due to the following reason:
${failReason}

Raw test results:
${executionResult}`;
                if (feedback.length > MAX_FEEDBACK_SIZE) {
                    feedback =
                        feedback.substring(0, MAX_FEEDBACK_SIZE) +
                        '... (truncated)';
                }
                // Try again with the feedback
                continue;
            }
        } catch (error) {
            console.error('Error processing tool implementation:', error);
            console.error('Raw response:', response);
            feedback = `Error with implementation: ${error instanceof Error ? error.message : String(error)}`;
            // Try again with the feedback
            continue;
        }
    }

    console.error(
        `Failed to create a working tool after ${maxAttempts} attempts`
    );
    return null;
}

/**
 * Extract parameter names from a function signature
 * @param implementation The function implementation string
 * @returns Array of parameter names in order
 */
function extractParameterNames(implementation: string): string[] {
    const funcSignatureMatch = implementation.match(
        /function\s+\w+\s*\(([^)]*)\)/
    );
    return funcSignatureMatch
        ? funcSignatureMatch[1]
              .split(',')
              .map(p => {
                  // Trim, get part before ':', trim again, and remove trailing '?' for optional params
                  return p.trim().split(':')[0].trim().replace(/\?$/, '');
              })
              .filter(p => p.length > 0) // Filter out empty strings if any (e.g. trailing comma)
        : [];
}

/**
 * Prepare argument array based on function parameters and input.
 * This function assumes `inputString` is typically a JSON string representing an object
 * where keys are parameter names and values are their corresponding values.
 * It maps these values to an array of positional arguments based on the function signature.
 *
 * @param implementation Function implementation string (to extract parameter names)
 * @param inputString The input, usually a JSON string of an object (e.g., from `final_parameter_values`)
 * @param parametersSchema Optional schema, mainly for `keyMapping` if input keys differ from param names (e.g. original vs snake_case)
 * @returns Array of arguments matched to parameter positions
 */
function prepareArguments(
    implementation: string,
    inputString: string,
    parametersSchema?: any
): any[] {
    const paramNames = extractParameterNames(implementation); // e.g., ['url'] or ['url', 'filepath']

    if (paramNames.length === 0) {
        return []; // No parameters, return empty array
    }

    let inputObj: any;
    try {
        // Assume inputString is a JSON representation of the arguments object
        inputObj = JSON.parse(inputString);
    } catch (e) {
        // If inputString is not valid JSON:
        // If the function expects a single parameter, assume inputString is that direct value.
        if (paramNames.length === 1) {
            return [inputString];
        }
        // If multiple parameters are expected but inputString is not a parsable object,
        // this is an ambiguous situation. Log a warning and return undefined for all params.
        console.warn(
            `prepareArguments: inputString is not a valid JSON object string, but multiple parameters are expected by function ${implementation.substring(0, 100)}...`
        );
        return paramNames.map(() => undefined); // Or throw an error
    }

    // Ensure inputObj is an object, as properties will be accessed.
    if (typeof inputObj !== 'object' || inputObj === null) {
        // If inputObj is not an object (e.g., a string, number, array from JSON.parse)
        // and the function expects a single parameter, pass inputObj as that single argument.
        if (paramNames.length === 1) {
            return [inputObj];
        }
        console.warn(
            `prepareArguments: Parsed input is not an object, but multiple parameters are expected by function ${implementation.substring(0, 100)}...`
        );
        return paramNames.map(() => undefined); // Or throw an error
    }

    const args: any[] = [];
    // keyMapping from schema might be used if inputObj keys are different from paramNames (e.g. originalName vs snake_case name)
    // However, final_parameter_values (usual source of inputObj) should use keys from the *final* parameters_json (which are snake_cased).
    const keyMapping = parametersSchema?.keyMapping || {};
    const reverseMapping: Record<string, string> = {};
    if (typeof keyMapping === 'object' && keyMapping !== null) {
        for (const [original, snakeCase] of Object.entries(keyMapping)) {
            if (typeof snakeCase === 'string') {
                reverseMapping[snakeCase] = original as string;
            }
        }
    }

    for (const paramName of paramNames) {
        let valueFound = false;
        // 1. Direct match: paramName (from function signature) is a key in inputObj
        if (paramName in inputObj) {
            args.push(inputObj[paramName]);
            valueFound = true;
        }
        // 2. Via reverseMapping: paramName is snake_case, inputObj might have original_case key
        // This is less likely if inputObj comes from final_parameter_values which should use final (snake_case) keys.
        else if (
            reverseMapping[paramName] &&
            reverseMapping[paramName] in inputObj
        ) {
            args.push(inputObj[reverseMapping[paramName]]);
            valueFound = true;
        }

        if (!valueFound) {
            // If parameter is not found in inputObj, push undefined.
            // This maintains argument order and arity for the function call.
            args.push(undefined);
        }
    }
    return args;
}

/**
 * Create a custom tool based on a description using a two-step process:
 *
 * 1. First generate the tool specification (name, description, parameters)
 * 2. Then generate the implementation code
 *
 * The function:
 * 1. Searches for existing tools with a similar description
 * 2. If found, returns the existing tool
 * 3. If not found, uses a two-step process to create a new tool:
 *    a. Generate specs with a focused LLM call
 *    b. Generate implementation with CodeAgent
 * 4. Tests the tool with the provided input
 * 5. Verifies the result meets expectations
 * 6. If verification fails, loops back to fix the implementation
 * 7. Stores the working tool in the database
 * 8. Makes the tool immediately available to the calling agent
 *
 * @param inject_agent_id The ID of the agent creating the tool
 * @param problem A description of the problem the tool should solve
 * @param input Sample input for the tool to process
 * @param result Description of the expected result
 * @returns A string describing the created or found tool
 */
export async function CUSTOM_TOOL(
    inject_agent_id: string,
    problem: string,
    input: string,
    result: string,
    force_new: boolean = false
): Promise<string> {
    console.log(`Creating custom tool to solve ${problem}`);
    const MAX_ATTEMPTS = 10; // Maximum number of tool generation/fix attempts

    try {
        const description = `${problem} -> ${result}`;

        // Generate embedding for description once and reuse
        const embedding = await ensembleEmbed(description, {
            model: 'text-embedding-3-small',
        });

        // ------------------------------------------------------------------
        // 1  Existing-tool discovery phase (unless force_new is true)
        // ------------------------------------------------------------------
        let existingToolData: CustomTool | null = null;

        if (!force_new) {
            const candidateTools = await searchCustomToolsByEmbedding(
                embedding,
                0.8,
                10
            );

            if (candidateTools.length > 0) {
                existingToolData = await llmPickBestTool(
                    problem,
                    candidateTools
                );
            }
        }

        // If a suitable existing tool was selected, use/return it
        if (existingToolData) {
            console.log(
                `Selected existing tool via LLM re-rank: ${existingToolData.name}`
            );

            let parsedParameters;
            try {
                parsedParameters = JSON.parse(existingToolData.parameters_json);
            } catch (e) {
                console.error(
                    `Error parsing parameters_json for existing tool ${existingToolData.name}: ${existingToolData.parameters_json}`,
                    e
                );
                // Fallback to a simple object if parsing fails, to prevent crashes
                parsedParameters = {
                    type: 'object',
                    properties: {
                        error: {
                            type: 'string',
                            description: 'Could not parse parameters',
                        },
                    },
                };
            }

            // Convert to ToolFunction. This also caches it in the global toolCache.
            const toolFunction =
                convertCustomToolToToolFunction(existingToolData);

            // Add to agent's specific tool cache (agentToolCache)
            addOrUpdateToolInAgentCache(inject_agent_id, toolFunction);

            // Attempt to execute the existing tool with the provided input
            let executionOutput = '';
            let executionError = '';
            try {
                // 'input' here is the original input string passed to CUSTOM_TOOL
                const args = prepareArguments(
                    existingToolData.implementation,
                    input,
                    parsedParameters // Use the parsed parameters object
                );

                executionOutput = await executeToolInSandbox({
                    codeString: existingToolData.implementation,
                    functionName: existingToolData.name,
                    agentId: inject_agent_id || '',
                    args: args,
                });
            } catch (e) {
                console.error(
                    `Error executing existing tool ${existingToolData.name}:`,
                    e
                );
                executionError = `Error trying to run existing tool ${existingToolData.name} with the provided input ("${input}"): ${e instanceof Error ? e.message : String(e)}`;
            }

            const paramsString = JSON.stringify(parsedParameters, null, 2); // Correct parameter display

            let resultMessage = `Found existing tool: ${existingToolData.name}
Description: ${existingToolData.description}
Parameters: ${paramsString}

This tool is now available in your toolset.`;

            if (executionError) {
                resultMessage += `\n\n${executionError}`;
            } else {
                // If successfully executed, return the output directly instead of a message about the tool
                // This makes the tool behave as if it was directly called
                return executionOutput;
            }
            return resultMessage;
        }

        // No similar tool found, create a new one using CodeAgent
        console.log('No similar tool found, creating a new one...');

        // Generate tool spec first
        let toolSpec;
        let generatedTool: GeneratedTool | null = null;
        let toolFunction: ToolFunction | null = null;

        // Variable we'll use throughout the function
        let adaptedInputString = '{}';

        try {
            // Generate new spec with potential generalization and adapted values
            const toolSpecWithAdaptedValues = await generateToolSpec(
                problem,
                input,
                result
            );

            // Create a string version of the adapted values to use for testing
            adaptedInputString = JSON.stringify(
                toolSpecWithAdaptedValues.final_parameter_values
            );

            console.log(
                `Generated tool spec: ${toolSpecWithAdaptedValues.name}`
            );
            console.log(
                `Using adapted parameter values: ${adaptedInputString}`
            );

            // Extract the core tool spec to use with _generateAndValidateImplementation
            toolSpec = {
                name: toolSpecWithAdaptedValues.name,
                description: toolSpecWithAdaptedValues.description,
                parameters_json: toolSpecWithAdaptedValues.parameters_json,
            };

            // Use the helper function to generate and validate the implementation
            generatedTool = await _generateAndValidateImplementation(
                toolSpec,
                inject_agent_id,
                problem,
                adaptedInputString, // Use the adapted input values for testing
                result,
                undefined, // No existing implementation
                null, // No initial feedback
                MAX_ATTEMPTS
            );
        } catch (error) {
            console.error('Error generating tool spec:', error);
            return `Error generating tool specification: ${error instanceof Error ? error.message : String(error)}`;
        }

        // Check if we succeeded
        if (!generatedTool) {
            console.error(
                `Failed to create a working tool after ${MAX_ATTEMPTS} attempts`
            );
            return `Error creating custom tool after ${MAX_ATTEMPTS} attempts: Unable to generate a valid implementation`;
        }

        // At this point, the tool has been validated and works
        // Store it in the database
        const customTool: CustomTool = {
            name: generatedTool.name,
            description: generatedTool.description,
            parameters_json: JSON.stringify(generatedTool.parameters_json),
            implementation: generatedTool.implementation,
            embedding: embedding,
            version: 1,
            is_latest: true,
        };

        const toolName = await addCustomTool(customTool);
        console.log(`Added new custom tool: ${toolName}`);

        // Create a tool function for immediate use
        toolFunction = convertCustomToolToToolFunction(customTool);

        // Execute the tool with the adapted parameter values to get the output for display
        const args = prepareArguments(
            generatedTool.implementation,
            adaptedInputString, // Use the adapted values, not the original input
            generatedTool.parameters_json
        );
        const output = await executeToolInSandbox({
            codeString: generatedTool.implementation,
            functionName: generatedTool.name,
            agentId: inject_agent_id || '',
            args: args,
        });

        // Add the tool to this agent's toolset
        addOrUpdateToolInAgentCache(inject_agent_id, toolFunction);

        return `Created new tool: ${generatedTool.name}()
Description: ${generatedTool.description}
Parameters: ${JSON.stringify(generatedTool.parameters_json, null, 2)}
This tool is now available in your toolset.

This tool has already been run with the input you provided "${input}" and generated the output:
\`\`\`
${output}
\`\`\``;
    } catch (error) {
        console.error('Error in CUSTOM_TOOL:', error);
        return `Error creating custom tool: ${error instanceof Error ? error.message : String(error)}`;
    }
}

/**
 * Modify an existing custom tool
 *
 * @param inject_agent_id The ID of the agent modifying the tool
 * @param name The name of the existing tool to modify
 * @param modification_request Description of the modifications to make
 * @returns A string describing the modified tool
 */
export async function modify_tool(
    inject_agent_id: string,
    name: string,
    modification_request: string
): Promise<string> {
    console.log(
        `Modifying custom tool '${name}' with request: ${modification_request}`
    );

    try {
        // Get the existing tool
        const existingTool = await getCustomToolByName(name);

        if (!existingTool) {
            return `Error: Tool '${name}' not found. You must specify the exact name of an existing custom tool.`;
        }

        // Generate updated spec using the unified resolver
        try {
            // Parse the parameters_json from string to object
            const paramsJson =
                typeof existingTool.parameters_json === 'string'
                    ? JSON.parse(existingTool.parameters_json)
                    : existingTool.parameters_json;

            // Create the existing tool spec for _resolveToolSpecification
            const existingSpec = {
                name: existingTool.name,
                description: existingTool.description,
                parameters_json: paramsJson,
            };

            // Use the unified resolver to get updated spec with adapted parameter values
            const updatedSpec = await _resolveToolSpecification({
                problemDescription: modification_request,
                existingToolSpec: existingSpec,
            });

            // Get adapted parameter values as a string for testing
            const adaptedInputString = JSON.stringify(
                updatedSpec.final_parameter_values
            );
            console.log('Using adapted parameter values:', adaptedInputString);

            // Generate and validate the implementation using the helper function
            const generatedTool = await _generateAndValidateImplementation(
                updatedSpec, // Use the updated spec directly
                inject_agent_id,
                modification_request, // Use the modification request as the "problem"
                adaptedInputString, // Use the adapted input values for testing
                'A successfully modified tool that meets all requirements.', // Generic expected result
                existingTool.implementation, // Pass the existing implementation
                null, // No initial feedback
                10 // Maximum attempts
            );

            // Check if we got a valid implementation
            if (!generatedTool) {
                console.error(
                    'Failed to create a working modified tool after 10 attempts'
                );
                return 'Error modifying custom tool: Failed to generate a valid implementation.';
            }

            // Generate embedding for the new description
            const embedding = await ensembleEmbed(generatedTool.description, {
                model: 'text-embedding-3-small',
            });

            // Store the modified tool in the database with incremented version
            const customTool: CustomTool = {
                name: generatedTool.name,
                description: generatedTool.description,
                parameters_json: JSON.stringify(generatedTool.parameters_json),
                implementation: generatedTool.implementation,
                embedding: embedding,
                version: (existingTool.version || 1) + 1,
                is_latest: true,
            };

            const toolName = await addCustomTool(customTool);
            console.log(`Added modified custom tool: ${toolName}`);

            // Convert the tool to a ToolFunction
            const toolFunction = convertCustomToolToToolFunction(customTool);

            // Update the agent's toolset with the modified version
            addOrUpdateToolInAgentCache(inject_agent_id, toolFunction);

            return `Modified tool: ${generatedTool.name}
Description: ${generatedTool.description}
Parameters: ${JSON.stringify(generatedTool.parameters_json, null, 2)}

This modified tool is now available in your toolset.`;
        } catch (error) {
            console.error(
                'Error generating or validating modified tool:',
                error
            );
            return `Error modifying custom tool: ${error instanceof Error ? error.message : String(error)}`;
        }
    } catch (error) {
        console.error('Error in modify_tool:', error);
        return `Error modifying custom tool: ${error instanceof Error ? error.message : String(error)}`;
    }
}

/**
 * Convert a CustomTool database record to a ToolFunction
 * This creates an executable function from the stored implementation
 * @param tool The custom tool database record
 * @returns A ToolFunction that can be called by agents
 */
function convertCustomToolToToolFunction(tool: CustomTool): ToolFunction {
    // Check if we already have this tool in cache
    const cacheKey = `${tool.name}_v${tool.version}`;
    if (toolCache.has(cacheKey)) {
        return toolCache.get(cacheKey)!;
    }

    // Parse parameters JSON
    let parametersObj: object;
    try {
        parametersObj =
            typeof tool.parameters_json === 'string'
                ? JSON.parse(tool.parameters_json)
                : tool.parameters_json;
    } catch (error) {
        console.error(
            `Error parsing parameters_json for tool ${tool.name}:`,
            error
        );
        parametersObj = {
            type: 'object',
            properties: {},
            required: [],
        };
    }

    // Create a function wrapper that safely executes the implementation in a VM
    let functionImpl: (...args: any[]) => Promise<string>;
    try {
        // Create a function that will execute the implementation in a VM with agent context
        functionImpl = async (...args: any[]): Promise<string> => {
            // Extract agent_id from the first argument if present
            const agent_id = args.length > 0 ? args[0] : undefined;
            let result: string;
            try {
                result = await executeToolInSandbox({
                    codeString: tool.implementation,
                    functionName: tool.name,
                    agentId: agent_id || '',
                    args: args,
                });
            } catch (error) {
                result = `Error executing custom tool: ${error instanceof Error ? error.message : String(error)}`;
            }

            // Auto-update the tool if execution failed
            if (
                typeof result === 'string' &&
                result.trim().toLowerCase().startsWith('error')
            ) {
                console.log(
                    `[custom_tool_utils] Auto fixing tool ${tool.name} due to runtime failure`
                );
                try {
                    await modify_tool(
                        agent_id || '',
                        tool.name,
                        `Auto fix due to error: ${result.substring(0, 200)}`
                    );
                    const updated = await getCustomToolByName(tool.name);
                    if (
                        updated &&
                        updated.version &&
                        updated.version !== tool.version
                    ) {
                        const updatedFunc =
                            convertCustomToolToToolFunction(updated);
                        addOrUpdateToolInAgentCache(
                            agent_id || '',
                            updatedFunc
                        );
                        return await updatedFunc.function(...args);
                    }
                } catch (updateErr) {
                    console.error(
                        '[custom_tool_utils] Auto update failed:',
                        updateErr
                    );
                }
            }

            return result;
        };
    } catch (error) {
        console.error(
            `Error creating function from implementation for tool ${tool.name}:`,
            error
        );
        functionImpl = async () =>
            `Error: Could not execute custom tool ${tool.name} due to implementation errors.`;
    }

    // Create the tool function
    const toolFunction = createToolFunction(
        functionImpl,
        tool.description,
        {}, // Empty param map since we'll set the full schema directly
        'Custom tool result',
        tool.name
    );

    // Directly set the parameters schema from the stored JSON
    toolFunction.definition.function.parameters = parametersObj as any;

    // Cache the tool function
    toolCache.set(cacheKey, toolFunction);

    return toolFunction;
}
