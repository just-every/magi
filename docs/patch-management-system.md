# Patch Management System

## Overview

The MAGI Patch Management System provides intelligent risk assessment and auto-merge capabilities for code changes generated by AI agents. It replaces the previous branch-based workflow with a safer, patch-based approach that allows for better control and review of changes.

## Key Features

### 1. Risk Assessment
- **Automatic risk scoring** based on:
  - File types and paths (e.g., database migrations, config files)
  - Code patterns (e.g., DROP TABLE, rm -rf, sudo)
  - Patch size and complexity
  - Developer familiarity metrics
  - Entropy and dispersion of changes

- **Risk levels**:
  - **Low** (0-0.25): Simple, safe changes
  - **Moderate** (0.26-0.55): Standard changes with some complexity
  - **High** (0.56-0.75): Complex or potentially risky changes
  - **Critical** (0.76-1.0): Very risky changes requiring careful review

### 2. Auto-Merge Policies

Configured via environment variables:

```bash
# For MAGI-generated projects
AUTO_MERGE_MAGI_PROJECTS=all          # Options: none, low_risk, moderate_risk, all

# For external/existing projects
AUTO_MERGE_EXISTING_PROJECTS=low_risk # Options: none, low_risk, moderate_risk, all
```

**Policy behaviors**:
- `none`: No automatic merging, all patches require manual review
- `low_risk`: Only auto-merge patches with low risk scores
- `moderate_risk`: Auto-merge low and moderate risk patches
- `all`: Auto-merge everything except critical risk patches

### 3. Conflict Resolution

The system provides intelligent conflict resolution:

1. **Automatic detection** of merge conflicts
2. **Smart suggestions** based on patch age and complexity:
   - **Rebase**: For recent patches (<24 hours)
   - **Regenerate**: For older patches (>24 hours)
   - **Three-way merge**: For complex conflicts
   - **Manual resolution**: Always available as fallback

3. **Auto-resolution** for simple conflicts using git's 3-way merge

## Architecture

### Database Schema

```sql
CREATE TABLE patches (
  id               BIGSERIAL PRIMARY KEY,
  process_id       TEXT        NOT NULL,
  project_id       TEXT        NOT NULL,
  branch_name      TEXT        NOT NULL,
  commit_message   TEXT        NOT NULL,
  patch_content    TEXT        NOT NULL,
  metrics          JSONB,
  status           TEXT        NOT NULL DEFAULT 'pending',
  created_at       TIMESTAMPTZ DEFAULT NOW(),
  applied_at       TIMESTAMPTZ,
  applied_by       TEXT,
  rejection_reason TEXT,
  merge_commit_sha TEXT
);
```

### Key Components

1. **patch_manager.ts**: Core patch management logic
   - Risk assessment
   - Auto-merge decisions
   - Patch application

2. **conflict_resolver.ts**: Conflict resolution strategies
   - Conflict detection
   - Resolution suggestions
   - Auto-resolution attempts

3. **process_manager.ts**: Integration with MAGI agents
   - Handles git_pull_request events
   - Triggers auto-merge based on risk
   - Emits UI events

4. **patches.ts** (API routes): REST endpoints
   - GET /api/patches - List patches with risk assessment
   - POST /api/patches/:id/apply - Manual merge
   - POST /api/patches/:id/check-conflicts - Check for conflicts
   - POST /api/patches/process-pending - Batch auto-merge

5. **PatchesViewer.tsx**: React UI component
   - Displays patches with risk levels
   - Shows auto-merge eligibility
   - Manual merge buttons
   - Real-time updates via Socket.IO

## Workflow

### 1. Patch Creation
When an agent makes code changes:
1. Agent creates a git diff patch
2. Patch is stored in database with metadata
3. Risk assessment is performed
4. `git_pull_request` event is emitted

### 2. Auto-Merge Decision
The system evaluates:
1. Is this a generated or external project?
2. What's the configured merge policy?
3. What's the patch risk level?
4. Are there any conflicts?

### 3. Merge Process
For auto-mergeable patches:
1. System checks for conflicts
2. If clean, applies patch and commits
3. Updates patch status in database
4. Emits success event to UI

For manual review patches:
1. Patch appears in UI with risk info
2. User can review and click "Merge"
3. System checks conflicts before applying
4. If conflicts, suggests resolution strategies

### 4. Conflict Resolution
When conflicts occur:
1. System analyzes conflict type and severity
2. Suggests resolution strategies
3. Can attempt auto-resolution for simple cases
4. Can create tasks for agents to resolve complex conflicts

## API Reference

### Risk Assessment
```typescript
interface PatchRiskAssessment {
    riskLevel: 'low' | 'moderate' | 'high' | 'critical';
    riskScore: number;        // 0.0 to 1.0
    canAutoMerge: boolean;
    reasons: string[];        // Risk factors found
    recommendation: string;   // Human-readable recommendation
}
```

### Conflict Resolution
```typescript
interface ConflictResolution {
    strategy: 'rebase' | 'merge' | 'regenerate' | 'manual';
    description: string;
    steps: string[];
    commands?: string[];
    confidence: 'high' | 'medium' | 'low';
}
```

## Configuration

### Environment Variables
```bash
# Merge policies
AUTO_MERGE_MAGI_PROJECTS=all
AUTO_MERGE_EXISTING_PROJECTS=low_risk

# Risk thresholds (optional)
LOW_RISK_MAX=0.25
MOD_RISK_MAX=0.55
HIGH_RISK_MAX=0.75

# Metric weights (optional)
W_FILES=0.10      # Weight for number of files changed
W_LOC=0.10        # Weight for lines of code
W_ENTROPY=0.10    # Weight for change entropy
W_CHURN=0.10      # Weight for code churn
W_HAZARD=0.15     # Weight for hazardous patterns
W_SECRET=0.15     # Weight for potential secrets
```

## Best Practices

1. **For Generated Projects**: Use `all` or `moderate_risk` policy for faster iteration
2. **For External Projects**: Use `low_risk` or `none` for safety
3. **Monitor Logs**: Check process logs for merge decisions and risk factors
4. **Review High-Risk**: Always manually review high/critical risk patches
5. **Handle Conflicts Promptly**: Resolve conflicts quickly to avoid patch staleness

## Troubleshooting

### Common Issues

1. **Patch won't auto-merge despite low risk**
   - Check merge policy configuration
   - Verify project type (generated vs external)
   - Look for conflicts

2. **Conflicts detected but patch looks clean**
   - Pull latest changes in the project
   - Check if patch is stale (>24 hours old)
   - Try regenerating the patch

3. **Auto-resolution fails**
   - Complex conflicts require manual intervention
   - Use suggested resolution strategies
   - Consider creating an agent task for resolution

### Debug Commands

```bash
# Check current policies
echo $AUTO_MERGE_MAGI_PROJECTS
echo $AUTO_MERGE_EXISTING_PROJECTS

# Test risk assessment
curl -X GET http://localhost:3010/api/patches

# Check specific patch conflicts
curl -X POST http://localhost:3010/api/patches/:id/check-conflicts \
  -H "Content-Type: application/json" \
  -d '{"projectId": "...", "processId": "..."}'
```

## Security Considerations

1. **Dangerous Patterns**: The system detects and flags:
   - SQL destructive operations (DROP, TRUNCATE)
   - File system dangerous commands (rm -rf)
   - Privilege escalation (sudo, setuid)
   - Hardcoded credentials

2. **Critical Files**: Extra caution for:
   - .env files
   - docker-compose.yml
   - Package dependency files
   - Database migrations

3. **Review Requirements**: Critical risk patches always require manual review, regardless of policy settings